<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux cgroup</title>
    <url>/posts/85b55b6f.html</url>
    <content><![CDATA[<h1 id="Linux-cgroup"><a href="#Linux-cgroup" class="headerlink" title="Linux cgroup"></a>Linux cgroup</h1><blockquote>
<p>全文基于 CentOS 7.4</p>
</blockquote>
<p>cgroup 是 Linux kernel 的一项功能，用来做资源限制的<br>systemd 是管理进程的<br>cgroup 层级系统+ systemd 可以把资源管理设置从<strong>进程级别移至应用程序级别</strong></p>
<p>本文首先将介绍如何在systemd 中对应用做资源限制<br>然后介绍如何手动配置 cgroup</p>
<a id="more"></a>

<h1 id="systemd-中-cgroup-的默认层级"><a href="#systemd-中-cgroup-的默认层级" class="headerlink" title="systemd 中 cgroup 的默认层级"></a>systemd 中 cgroup 的默认层级</h1><p>默认情况下，systemd 会在cgroup下自动创建 slice、scope 和 service 单位的层级</p>
<ul>
<li>name.service<br>一个或一组进程</li>
<li>name.scope<br>一组外部创建的进程</li>
<li>parent-name.slice<br>一组按层级排列的单位。slice 并不包含进程<br>子层标识父的名称</li>
</ul>
<p>使用 <code>systemd-cgls</code> 可以查看</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">├─1 /usr/lib/systemd/systemd --switched-root --system --deserialize 21</span><br><span class="line">├─docker</span><br><span class="line">│ └─60684a93a27ee26bcc5dd062bb2d453ee9a409d665e01577f0061a0fe2cfd40a</span><br><span class="line">│   └─2922 mysqld</span><br><span class="line">├─user.slice</span><br><span class="line">│ └─user-0.slice</span><br><span class="line">│   └─session-79.scope</span><br><span class="line">│     ├─4527 sshd: root@pts/0    </span><br><span class="line">│     ├─4529 -bash</span><br><span class="line">│     ├─4584 systemd-cgls</span><br><span class="line">│     └─4585 less</span><br><span class="line">└─system.slice</span><br><span class="line">  ├─docker.service</span><br><span class="line">  │ ├─2671 /usr/bin/dockerd</span><br><span class="line">  │ ├─2683 docker-containerd -l unix:///var/run/docker/libcontainerd/docker-containerd.sock --metrics-interval=0 --start-timeout 2m --state-dir /var/run/docker/libcontainerd/containerd --sh</span><br><span class="line">  │ ├─2898 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 3306 -container-ip 172.20.0.2 -container-port 3306</span><br><span class="line">  │ └─2905 docker-containerd-shim 60684a93a27ee26bcc5dd062bb2d453ee9a409d665e01577f0061a0fe2cfd40a /var/run/docker/libcontainerd/60684a93a27ee26bcc5dd062bb2d453ee9a409d665e01577f0061a0fe2cf</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>slice 是个逻辑分组，service、scope才是进程运行的地方</p>
</blockquote>
<h1 id="在systemd-中使用-cgroup"><a href="#在systemd-中使用-cgroup" class="headerlink" title="在systemd 中使用 cgroup"></a>在systemd 中使用 cgroup</h1><p>首先systemd 启动进程分为临时、永久两种方式</p>
<p>临时：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemd-run --unit=name --scope --slice=slice_name <span class="built_in">command</span></span><br></pre></td></tr></table></figure>

<h2 id="使用systemd-管理进程"><a href="#使用systemd-管理进程" class="headerlink" title="使用systemd 管理进程"></a>使用systemd 管理进程</h2><p>创建一个测试例子，来验证cgroup 对cpu的限制</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tee /usr/lib/systemd/system/test.service&lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">[Service]</span></span><br><span class="line"><span class="string">ExecStart=/usr/bin/stress --cpu 10</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>这样启动后通过<code>top</code>可观察到cpu占用为100%</p>
<h2 id="设置资源限制"><a href="#设置资源限制" class="headerlink" title="设置资源限制"></a>设置资源限制</h2><p>使用命令去修改 cgroup</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl set-property --runtime <span class="built_in">test</span> CPUQuota=10%</span><br></pre></td></tr></table></figure>

<p>如果不添加 <code>runtime</code> 参数，这个资源限制会被持久化到文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat /etc/systemd/system/test.service.d/50-CPUQuota.conf </span></span><br><span class="line">[Service]</span><br><span class="line">CPUQuota=10%</span><br></pre></td></tr></table></figure>

<p>这时候可直接观察到cpu占用降低到10%</p>
<p>这里列下常用配置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line"><span class="comment"># 默认 1024 代表 1core  相对使用率</span></span><br><span class="line">CPUShares=1500</span><br><span class="line"><span class="comment"># 占用比例 按单核算</span></span><br><span class="line">CPUQuota=110%</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最大可用内存  单位（K、M、G、T ）</span></span><br><span class="line">MemoryLimit=1G</span><br></pre></td></tr></table></figure>



<p>更多详细配置参考<a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/resource_management_guide/sec-Modifying_Control_Groups#sec-Modifying_Unit_Files">修改 CGROUP</a></p>
<blockquote>
<p>cgroup = v1</p>
</blockquote>
<h1 id="cgroup-的手动配置"><a href="#cgroup-的手动配置" class="headerlink" title="cgroup 的手动配置"></a>cgroup 的手动配置</h1><p>内核使用文件系统来配置cgroup</p>
<h2 id="hierarchy-层级"><a href="#hierarchy-层级" class="headerlink" title="hierarchy(层级)"></a>hierarchy(层级)</h2><p>通过虚拟的文件系统，维护了一个树<br>描述了<code>cgroup</code>之间的从属关系，这种结构意味着配置是可以继承的<br>通过写入树下的文件，对<code>cgroup</code>配置进行修改</p>
<blockquote>
<p>这里只展示创建 cgroup 的层级关系，把进程添加到里面去（不包含资源限制）</p>
</blockquote>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建目录，并且挂载为 cgroup 类型</span></span><br><span class="line">mkdir cgroup-test</span><br><span class="line">mount -t cgroup -o none,name=cgroup-test cgroup-test ./cgroup-test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载后可以看到里面创建的文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ls -1 ./cgroup-test/</span></span><br><span class="line">cgroup.clone_children   <span class="comment"># 默认0，如果1，那么子cgroup会继承父的配置</span></span><br><span class="line">cgroup.event_control    <span class="comment"># </span></span><br><span class="line">cgroup.procs            <span class="comment"># 包含系统里所有进程</span></span><br><span class="line">cgroup.sane_behavior</span><br><span class="line">notify_on_release</span><br><span class="line">release_agent</span><br><span class="line">tasks                   <span class="comment"># 当前 cgroup 下进程</span></span><br></pre></td></tr></table></figure>

<p>注意到 <code>-o none</code> 意味着这个挂载后目录是虚拟的</p>
<h3 id="创建子cgroup"><a href="#创建子cgroup" class="headerlink" title="创建子cgroup"></a>创建子cgroup</h3><p>只需要在<code>cgroup-test</code>中 创建目录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@localhost cgroup-test]<span class="comment"># mkdir cgroup-1</span></span><br><span class="line">[root@localhost cgroup-test]<span class="comment"># mkdir cgroup-2</span></span><br><span class="line">[root@localhost cgroup-test]<span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">├── cgroup-1</span><br><span class="line">│   ├── cgroup.clone_children</span><br><span class="line">│   ├── cgroup.event_control</span><br><span class="line">│   ├── cgroup.procs</span><br><span class="line">│   ├── notify_on_release</span><br><span class="line">│   └── tasks</span><br><span class="line">├── cgroup-2</span><br><span class="line">│   ├── cgroup.clone_children</span><br><span class="line">│   ├── cgroup.event_control</span><br><span class="line">│   ├── cgroup.procs</span><br><span class="line">│   ├── notify_on_release</span><br><span class="line">│   └── tasks</span><br><span class="line">├── cgroup.clone_children</span><br><span class="line">├── cgroup.event_control</span><br><span class="line">├── cgroup.procs</span><br><span class="line">├── cgroup.sane_behavior</span><br><span class="line">├── notify_on_release</span><br><span class="line">├── release_agent</span><br><span class="line">└── tasks</span><br><span class="line"></span><br><span class="line">2 directories, 17 files</span><br></pre></td></tr></table></figure>

<h3 id="cgroup中添加进程"><a href="#cgroup中添加进程" class="headerlink" title="cgroup中添加进程"></a>cgroup中添加进程</h3><p>系统所有进程都默认挂在根节点上<br>添加进程通过向 <code>tasks</code> 写入<code>PID</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> $$ &gt;&gt; cgroup-1/tasks</span><br></pre></td></tr></table></figure>
<p>这样就可以加入到 <code>cgroup-1</code>中</p>
<blockquote>
<p>一个进程可以加入到多个<code>hierarchy</code>中</p>
</blockquote>
<p>之前提到<code>systemd</code> 维护的层，在文件系统里<code>/sys/fs/cgroup</code>  下面<br>像<code>/sys/fs/cgroup/systemd</code>、<code>/sys/fs/cgroup/cpu</code> 这些目录都是cgroup的层级</p>
<h2 id="subsystem"><a href="#subsystem" class="headerlink" title="subsystem"></a>subsystem</h2><p>资源控制的模块，每个模块下会有一个cgroup的hierarchy<br>通过在不同的hierarchy中对文件进行配置达到资源限制的效果</p>
<h3 id="查看系统支持的模块"><a href="#查看系统支持的模块" class="headerlink" title="查看系统支持的模块"></a>查看系统支持的模块</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y libcgroup-tools</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># lssubsys -a</span></span><br><span class="line">cpuset</span><br><span class="line">cpu,cpuacct</span><br><span class="line">memory</span><br><span class="line">devices</span><br><span class="line">freezer</span><br><span class="line">net_cls,net_prio</span><br><span class="line">blkio</span><br><span class="line">perf_event</span><br><span class="line">hugetlb</span><br><span class="line">pids</span><br></pre></td></tr></table></figure>

<p>这些模块会对指定的资源做限制，配置路径在<code>/sys/fs/cgroup/&lt;cpu&gt;</code></p>
<h3 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h3><p>之前在<code>systemd</code>里面对CPU做了限制，那么再去看下真正生效的地方<br>那么查看文件路径可以通过<code>systemd-cgls</code>找到</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">└─system.slice</span><br><span class="line">  ├─test.service</span><br><span class="line">  │ ├─6094 /usr/bin/stress --cpu 10</span><br><span class="line">  │ └─6095 /usr/bin/stress --cpu 10</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 <code>/sys/fs/cgroup/cpu/system.slice/test.service/</code> 下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat tasks </span></span><br><span class="line">6094</span><br><span class="line">6095</span><br><span class="line"><span class="comment"># 可以看到两个进程确实加入到这个cgroup中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cat cpu.cfs_period_us</span></span><br><span class="line">100000</span><br><span class="line"><span class="comment"># cat cpu.cfs_quota_us</span></span><br><span class="line">10000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>cpu.cfs_period_us: 指cgroup对资源调度周期 （微秒）<br>cpu.cfs_quota_us： 在一个周期（cpu.cfs_period_us定义），可以占用cpu的时间<br>一个周期内能占用多少cpu = cpu.cfs_quota_us / cpu.cfs_period_us<br>也就是设置的10%</p>
<p>然后设置个内存限制看看<br><code>systemctl set-property --runtime test MemoryLimit=128M</code><br>就可以在下面路径看到</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat /sys/fs/cgroup/memory/system.slice/test.service/memory.limit_in_bytes </span><br><span class="line">134217728</span><br></pre></td></tr></table></figure>


<p>systemd 里面参数和内核中配置对应关系</p>
<table>
<thead>
<tr>
<th>systemd option</th>
<th>cgroup</th>
</tr>
</thead>
<tbody><tr>
<td>CPUShares</td>
<td>cpu.shares</td>
</tr>
<tr>
<td>CPUQuota</td>
<td>cpu.cfs_quota_us</td>
</tr>
<tr>
<td>MemoryLimit</td>
<td>memory.limit_in_bytes</td>
</tr>
</tbody></table>
<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>docker 会给每个容器创建 cgroup，以<code>cpu</code>为例就是在<br><code>/sys/fs/cgroup/cpu/docker/</code></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/resource_management_guide/">资源管理指南</a><br><a href="https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt">CPU调度参数</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>cgroup</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7 中修改网卡名称</title>
    <url>/posts/1a6f476.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>CentOS7 开始，网卡名称变为随机值，用起来非常麻烦<br>在生产环境，网络地址一般配置为静态，网卡名称也要去一致<br>本文记录手动修改名称的一种方式</p>
<blockquote>
<p>基于原版CentOS 7.3.1611</p>
</blockquote>
<a id="more"></a>

<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>以<code>eno16777736</code>为例，修改为<code>eth0</code></p>
<h2 id="1-修改ifcfg-eno16777736"><a href="#1-修改ifcfg-eno16777736" class="headerlink" title="1. 修改ifcfg-eno16777736"></a>1. 修改ifcfg-eno16777736</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-eno16777736</span><br></pre></td></tr></table></figure>

<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">设置</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">PEERDNS=yes</span><br><span class="line">PEERROUTES=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line"><span class="deletion">- NAME=eno16777736</span></span><br><span class="line"><span class="addition">+ NAME=eth0</span></span><br><span class="line"><span class="deletion">- DEVICE=eno16777736</span></span><br><span class="line"><span class="addition">+ DEVICE=eth0</span></span><br><span class="line"><span class="addition">+ HWADDR=1f:1f:1f:1f:1f:1f</span></span><br><span class="line">IPADDR=10.33.100.100</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=10.33.100.254</span><br><span class="line">DNS1=8.8.8.8</span><br><span class="line">ONBOOT=yes</span><br></pre></td></tr></table></figure>

<p>这里需要确保 <code>HWADDR</code> 设置，否则后面绑定不到物理网卡上</p>
<h2 id="2-文件重命名"><a href="#2-文件重命名" class="headerlink" title="2. 文件重命名"></a>2. 文件重命名</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/sysconfig/network-scripts/</span><br><span class="line">mv ifcfg-eno16777736 ifcfg-eth0</span><br></pre></td></tr></table></figure>

<h2 id="3-修改grub"><a href="#3-修改grub" class="headerlink" title="3. 修改grub"></a>3. 修改grub</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi /etc/default/grub</span><br></pre></td></tr></table></figure>

<p>添加<code>net.ifnames=0 biosdevname=0</code>两个参数</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">- GRUB_CMDLINE_LINUX=&quot;crashkernel=128M rhgb net.ifnames=0 biosdevname=0 quiet&quot;</span></span><br><span class="line"><span class="addition">+ GRUB_CMDLINE_LINUX=&quot;crashkernel=128M rhgb net.ifnames=0 biosdevname=0 quiet net.ifnames=0 biosdevname=0&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-让配置生效"><a href="#4-让配置生效" class="headerlink" title="4. 让配置生效"></a>4. 让配置生效</h2><p>这里根据引导类型的不同，会有两种命令，都执行即可</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br><span class="line">grub2-mkconfig -o /boot/efi/EFI/centos/grub.cfg</span><br></pre></td></tr></table></figure>

<h2 id="5-修改rules文件"><a href="#5-修改rules文件" class="headerlink" title="5. 修改rules文件"></a>5. 修改rules文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi /usr/lib/udev/rules.d/60-net.rules</span><br></pre></td></tr></table></figure>

<p>删除原有内容，然后添加:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ACTION==<span class="string">&quot;add&quot;</span>, SUBSYSTEM==<span class="string">&quot;net&quot;</span>, DRIVERS==<span class="string">&quot;?*&quot;</span>, ATTR&#123;<span class="built_in">type</span>&#125;==<span class="string">&quot;1&quot;</span>, ATTR&#123;address&#125;==<span class="string">&quot;1f:1f:1f:1f:1f:1f&quot;</span>, NAME=<span class="string">&quot;eth0&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>⚠️mac地址要写正确<br>多个网卡都要在这里配置</p>
</blockquote>
<h3 id="6-重启"><a href="#6-重启" class="headerlink" title="6. 重启"></a>6. 重启</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">reboot now</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 7 安装 nvidia p4 驱动</title>
    <url>/posts/b79dc209.html</url>
    <content><![CDATA[<h1 id="CentOS-7-P4-驱动安装"><a href="#CentOS-7-P4-驱动安装" class="headerlink" title="CentOS 7 P4 驱动安装"></a>CentOS 7 P4 驱动安装</h1><h2 id="安装必备组件"><a href="#安装必备组件" class="headerlink" title="安装必备组件"></a>安装必备组件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install gcc kernel-devel kernel-headers -y</span><br></pre></td></tr></table></figure>

<p>👆这些组件都需要和当前内核版本一致，甚至和gcc 版本都有关系<br>为了简单处理，就直接升级到<strong>最新</strong>，然后重启系统</p>
<a id="more"></a>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum update kernel -y</span><br><span class="line">reboot now</span><br></pre></td></tr></table></figure>

<p>升级后内核是<code>3.10.0-693.21.1.el7.x86_64</code></p>
<h2 id="Disabling-Nouveau"><a href="#Disabling-Nouveau" class="headerlink" title="Disabling Nouveau"></a>Disabling Nouveau</h2><p>查看是否启动（有任何输出）<br><code>lsmod | grep nouveau</code></p>
<p>禁用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir -p /etc/modprobe.d</span><br><span class="line">tee /etc/modprobe.d/blacklist-nouveau.conf&lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">blacklist nouveau</span></span><br><span class="line"><span class="string">options nouveau modeset=0</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">sudo dracut --force</span><br></pre></td></tr></table></figure>
<p>然后重启再确认下，保证关闭</p>
<h2 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h2><p><a href="http://www.nvidia.com/Download/index.aspx?lang=cn">找驱动</a>，CentOS 选 <code>Linux 64</code>，不要选redhat的</p>
<p>下完是一个<code>run</code>文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chmod +x NVIDIA-Linux-x86_64-390.46.run</span><br><span class="line"></span><br><span class="line">./NVIDIA-Linux-x86_64-390.46.run -q -a -n -X -s  --kernel-source-path=/usr/src/kernels/3.10.0-693.21.1.el7.x86_64  -k $(uname -r)</span><br></pre></td></tr></table></figure>

<p>安装后使用 <code>nvidia-smi</code> 检查是否安装成功</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>gpu</tag>
        <tag>nvidia</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 网络虚拟化</title>
    <url>/posts/706085c3.html</url>
    <content><![CDATA[<h1 id="Linux-网络虚拟化"><a href="#Linux-网络虚拟化" class="headerlink" title="Linux 网络虚拟化"></a>Linux 网络虚拟化</h1><p>本文主要记录Linux 中网络虚拟化，以及基本的配置</p>
<p>全文基于 CentOS 7.4</p>
<a id="more"></a>
<h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>Namespace 技术可以创建独立的网络空间<br>使用 <code>ip netns</code> 管理的网络，其路径在<code>/var/run/netns/</code>，如果是docker创建的网络空间，要创建软链接过去，才能用这个指令管理</p>
<h3 id="管理-Namespace"><a href="#管理-Namespace" class="headerlink" title="管理 Namespace"></a>管理 Namespace</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加 ns</span></span><br><span class="line">ip netns add net0</span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">ip netns</span><br><span class="line"><span class="comment"># 在指定NS中操作</span></span><br><span class="line">ip netns <span class="built_in">exec</span> net0 /bin/bash --rcfile &lt;(<span class="built_in">echo</span> <span class="string">&quot;PS1=\&quot;ns net0&gt; \&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># del</span></span><br><span class="line">ip netns del net0</span><br></pre></td></tr></table></figure>

<p>默认创建后ns中只有一个lo的接口，并且是<code>down</code>，这种情况下，不能和其他主机网络，其他ns通信</p>
<blockquote>
<p><code>netns</code> 可以简写 <code>net</code></p>
</blockquote>
<h2 id="veth"><a href="#veth" class="headerlink" title="veth"></a>veth</h2><p>veth 是<strong>成对</strong>出现的网络设备，两个虚拟设备之间，有个直通的链路</p>
<h3 id="管理veth"><a href="#管理veth" class="headerlink" title="管理veth"></a>管理veth</h3><p>创建一对<code>veth pair</code>，这只能成对出现</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ip link add <span class="built_in">type</span> veth</span><br><span class="line"><span class="comment"># 手动指定名称</span></span><br><span class="line">ip link add veth0 <span class="built_in">type</span> veth peer name veth1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删一个，另一个也会删除掉</span></span><br><span class="line">ip link del veth0</span><br></pre></td></tr></table></figure>

<p>创建后可以看到</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">19: veth1@veth0: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000</span><br><span class="line">    link/ether f6:5f:3a:36:6e:73 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">20: veth0@veth1: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000</span><br><span class="line">    link/ether ea:53:eb:ff:d5:58 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>

<h2 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a>bridge</h2><p>相当于交换机，连接不同设备，依靠<code>mac</code>地址做转发</p>
<h3 id="管理-bridge"><a href="#管理-bridge" class="headerlink" title="管理 bridge"></a>管理 bridge</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># add</span></span><br><span class="line">ip link add br0 <span class="built_in">type</span> bridge</span><br><span class="line"></span><br><span class="line"><span class="comment"># up</span></span><br><span class="line">ip link <span class="built_in">set</span> dev br0 up</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把设备挂上去</span></span><br><span class="line">ip link <span class="built_in">set</span> dev eth1 master br0</span><br><span class="line"><span class="comment"># 取下来</span></span><br><span class="line">ip link <span class="built_in">set</span> dev eth1 nomaster</span><br></pre></td></tr></table></figure>

<h2 id="ns-之间通信"><a href="#ns-之间通信" class="headerlink" title="ns 之间通信"></a>ns 之间通信</h2><p>两个ns之间可以通过<code>veth pair</code>进行通信，意思就是在两个空间中加了个管道，拓扑如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+++++++++++++++++    +++++++++++++++++</span><br><span class="line">+      ns0      +    +      ns1      +</span><br><span class="line">+  -----------  +    +  -----------  +</span><br><span class="line">+  |  veth0  |----------|  veth1  |  +</span><br><span class="line">+  -----------  +    +  -----------  +</span><br><span class="line">+++++++++++++++++    +++++++++++++++++</span><br></pre></td></tr></table></figure>

<ul>
<li>创建veth</li>
<li>放入ns</li>
</ul>
<h3 id="创建veth"><a href="#创建veth" class="headerlink" title="创建veth"></a>创建veth</h3><p>接👆</p>
<h3 id="放入ns"><a href="#放入ns" class="headerlink" title="放入ns"></a>放入ns</h3><p>首先要把veth放入各自ns中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ip link <span class="built_in">set</span> veth0 netns net0</span><br><span class="line">ip link <span class="built_in">set</span> veth1 netns net1</span><br></pre></td></tr></table></figure>

<p>然后需要配置ip地址</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ip netns <span class="built_in">exec</span> net0 ip addr add 192.168.1.1/24 dev veth0</span><br><span class="line">ip netns <span class="built_in">exec</span> net1 ip addr add 192.168.1.2/24 dev veth1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里只要操作一个接口状态，另外一个会同步变化</span></span><br><span class="line">ip netns <span class="built_in">exec</span> net0 ip link <span class="built_in">set</span> veth0 up</span><br></pre></td></tr></table></figure>

<h2 id="使用bridge连接不同ns"><a href="#使用bridge连接不同ns" class="headerlink" title="使用bridge连接不同ns"></a>使用bridge连接不同ns</h2><p><code>veth pair</code>只能连接两个ns，当多个ns要通信时候需要使用<code>bridge</code><br>拓扑如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+++++++++++++++++    +++++++++++++++++</span><br><span class="line">+      ns0      +    +      ns1      +</span><br><span class="line">+  -----------  +    +  -----------  +</span><br><span class="line">+  |  veth1  |  +    +  |  veth3  |  +</span><br><span class="line">+  -----------  +    +  -----------  +</span><br><span class="line">+++++++ | +++++++    +++++++ | +++++++</span><br><span class="line">        |                    |</span><br><span class="line">        |--------------------|</span><br><span class="line">                  ||</span><br><span class="line">          &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">          &#x3D;      br0      &#x3D;</span><br><span class="line">          &#x3D;               &#x3D;</span><br><span class="line">          &#x3D; veth0   veth2 &#x3D;</span><br><span class="line">          &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">           </span><br></pre></td></tr></table></figure>

<h3 id="创建bridge"><a href="#创建bridge" class="headerlink" title="创建bridge"></a>创建bridge</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加</span></span><br><span class="line">ip link add br0 <span class="built_in">type</span> bridge</span><br><span class="line"><span class="comment"># 并且up</span></span><br><span class="line">ip link <span class="built_in">set</span> dev br0 up</span><br></pre></td></tr></table></figure>

<h3 id="创建veth-1"><a href="#创建veth-1" class="headerlink" title="创建veth"></a>创建veth</h3><p>创建 veth，并且一端加入ns，一端连接 bridge</p>
<p>首先和之前一样创建<code>veth</code>，假设已经创建了两对</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">veth0@veth1</span><br><span class="line">veth2@veth3</span><br></pre></td></tr></table></figure>

<h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把设备 veth0 加入到 br0</span></span><br><span class="line">ip link <span class="built_in">set</span> dev veth0 master br0</span><br><span class="line">ip link <span class="built_in">set</span> dev veth1 netns net0</span><br><span class="line">ip link <span class="built_in">set</span> dev veth2 master br0</span><br><span class="line">ip link <span class="built_in">set</span> dev veth3 netns net1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ip netns <span class="built_in">exec</span> net0 ip link <span class="built_in">set</span> dev veth1 name eth0</span><br><span class="line">ip netns <span class="built_in">exec</span> net0 ip addr add 192.168.1.2/24 dev eth0</span><br><span class="line"></span><br><span class="line">ip netns <span class="built_in">exec</span> net1 ip link <span class="built_in">set</span> dev veth3 name eth0</span><br><span class="line">ip netns <span class="built_in">exec</span> net1 ip addr add 192.168.1.3/24 dev eth0</span><br><span class="line"></span><br><span class="line">ip link <span class="built_in">set</span> dev veth0 up</span><br><span class="line">ip link <span class="built_in">set</span> dev veth2 up</span><br><span class="line"></span><br><span class="line">ip netns <span class="built_in">exec</span> net0 ip link <span class="built_in">set</span> dev eth0 up</span><br><span class="line">ip netns <span class="built_in">exec</span> net1 ip link <span class="built_in">set</span> dev eth0 up</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://cizixs.com/2017/02/10/network-virtualization-network-namespace">linux 网络虚拟化： network namespace 简介</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
        <tag>net</tag>
        <tag>virt</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes 中的RBAC</title>
    <url>/posts/bfe9b98e.html</url>
    <content><![CDATA[<h1 id="kubernetes-RBAC"><a href="#kubernetes-RBAC" class="headerlink" title="kubernetes RBAC"></a>kubernetes RBAC</h1><p>角色绑定将角色映射到一个用户或者一组用户，把角色在命名空间中对资源的权限授权给这些用户。ClusterRoleBinding（集群角色绑定）允许授权用户ClusterRole的在整个集群中的授权访问。</p>
<p>RBAC API定义了四个资源对象用于描述角色和权限、角色和用户的关系：</p>
<ul>
<li>Role</li>
<li>ClusterRole</li>
<li>RoleBinding</li>
<li>ClusterRoleBinding</li>
</ul>
<a id="more"></a>
<h2 id="Role-和-ClusterRole"><a href="#Role-和-ClusterRole" class="headerlink" title="Role 和 ClusterRole"></a>Role 和 ClusterRole</h2><p>描述角色和权限的关系</p>
<p>Roles 是限定在某个Namespace下的<br><code>kubectl get roles --all-namespaces</code></p>
<p>ClusterRole 是整个集群范围的<br><code>kubectl get clusterroles</code></p>
<h3 id="资源示例"><a href="#资源示例" class="headerlink" title="资源示例"></a>资源示例</h3><p>一条规则由 <code>apiGroups</code>、<code>resources</code>、<code>verbs</code> 共同组成，结构如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>] <span class="comment"># &quot;&quot; indicates the core API group</span></span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>ClusterRole 在资源结构上类似</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="comment"># 不能有&quot;namespace&quot;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;secrets&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br></pre></td></tr></table></figure>
<h2 id="RoleBinding-和-ClusterRoleBinding"><a href="#RoleBinding-和-ClusterRoleBinding" class="headerlink" title="RoleBinding 和 ClusterRoleBinding"></a>RoleBinding 和 ClusterRoleBinding</h2><p>描述 subjects （包含users, groups, service accounts）和 角色的关系</p>
<p>RoleBinding 是限定在某个Namespace下的<br><code>kubectl get rolebinding --all-namespaces</code></p>
<p>ClusterRoleBinding 是整个集群范围的<br><code>kubectl get clusterrolebinding</code></p>
<h3 id="资源示例-1"><a href="#资源示例-1" class="headerlink" title="资源示例"></a>资源示例</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This role binding allows &quot;jane&quot; to read pods in the &quot;default&quot; namespace.</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">read-pods</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">jane</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-reader</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This cluster role binding allows anyone in the &quot;manager&quot; group to read secrets in any namespace.</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">read-secrets-global</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Group</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">manager</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-reader</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<h3 id="subjects-使用示例"><a href="#subjects-使用示例" class="headerlink" title="subjects 使用示例"></a>subjects 使用示例</h3><p>subjects 是访问api 的主体<br>之前提到 subjects 包含users, groups, service accounts 三种类型，下面展示下具体写法</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&quot;nil@example.com&quot;</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Group</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&quot;frontend-admins&quot;</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br></pre></td></tr></table></figure>

<p>我们现有环境，k8s 组件访问 apiserver 使用基于证书的认证方式(双向)，apiserver 接受请求时会从client 证书中提取<br><code>CN</code>、<code>O</code>字段，分别作为 <code>subjects</code> 中的 <code>User</code> 和 <code>Group</code></p>
<p>下面是<code>kube-proxy</code>证书配置的示例，配内容可以查阅<a href="https://kubernetes.io/docs/admin/authorization/rbac/#discovery-roles">文档</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;CN&quot;</span>: <span class="string">&quot;system:kube-proxy&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hosts&quot;</span>: [<span class="string">&quot;&quot;</span>],</span><br><span class="line">    <span class="attr">&quot;key&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;algo&quot;</span>: <span class="string">&quot;rsa&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="number">2048</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;names&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;O&quot;</span>: <span class="string">&quot;system:nodes&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至于集群内访问 apiserver 均使用service accounts 来表示身份</p>
<h2 id="Kubernetes中默认的Role和RoleBinding"><a href="#Kubernetes中默认的Role和RoleBinding" class="headerlink" title="Kubernetes中默认的Role和RoleBinding"></a>Kubernetes中默认的Role和RoleBinding</h2><p>可以使用以下两个指令查看默认的权限设置<br><code>kubectl get clusterrole -l kubernetes.io/bootstrapping=rbac-defaults</code></p>
<p><code>kubectl get clusterrolebinding -l kubernetes.io/bootstrapping=rbac-defaults</code></p>
<h2 id="创建clusterrolebinding-示例"><a href="#创建clusterrolebinding-示例" class="headerlink" title="创建clusterrolebinding 示例"></a>创建clusterrolebinding 示例</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl create clusterrolebinding admin \</span><br><span class="line">--clusterrole=cluster-admin \</span><br><span class="line">--user=system:kube-controller-manager \</span><br><span class="line">--user=system:kube-scheduler \</span><br><span class="line">--group=system:kube-controller-manager</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>NIC 使用 sr-iov</title>
    <url>/posts/ccd392c5.html</url>
    <content><![CDATA[<h1 id="SR-IOV-网卡直通"><a href="#SR-IOV-网卡直通" class="headerlink" title="SR-IOV 网卡直通"></a>SR-IOV 网卡直通</h1><p>SR-IOV是一种基于硬件的虚拟化方案。用来使一个PCIe的物理设备，能虚拟出多个设备。</p>
<p>SR-IOV 中的两种新功能类型是：</p>
<ul>
<li><p>物理功能 (Physical Function, PF)<br>包括管理SR-IOV功能在内的所有PCIe function</p>
</li>
<li><p>虚拟功能 (Virtual Function, VF)<br>VF 是一种轻量级 PCIe 功能，VF 仅允许拥有用于其自身行为的配置资源。</p>
</li>
</ul>
<p>每个 SR-IOV 设备都可有一个物理功能 (Physical Function, PF)，并且每个 PF 最多可有 64,000 个与其关联的虚拟功能 (Virtual Function, VF)。PF 可以通过寄存器创建 VF，这些寄存器设计有专用于此目的的属性。</p>
<p>一旦在 PF 中启用了 SR-IOV，就可以通过 PF 的总线、设备和功能编号（路由 ID）访问各个 VF 的 PCI 配置空间。每个 VF 都具有一个 PCI 内存空间，用于映射其寄存器集。VF 设备驱动程序对寄存器集进行操作以启用其功能，并且显示为实际存在的 PCI 设备。创建 VF 后，可以直接将其指定给 IO 来宾域或各个应用程序（如裸机平台上的 Oracle Solaris Zones）。此功能使得虚拟功能可以共享物理设备，并在没有 CPU 和虚拟机管理程序软件开销的情况下执行 I/O。</p>
<a id="more"></a>
<h2 id="CentOS-7-开启"><a href="#CentOS-7-开启" class="headerlink" title="CentOS 7 开启"></a>CentOS 7 开启</h2><p>开启<code>VF</code>大概需要这几步：</p>
<ol>
<li>硬件支持</li>
<li>BIOS 开启 SR-IOV 、VT</li>
<li>开启IOMMU</li>
<li>配置PF</li>
</ol>
<blockquote>
<p>全文基于 Intel CPU</p>
</blockquote>
<h3 id="查看CPU是否支持虚拟化"><a href="#查看CPU是否支持虚拟化" class="headerlink" title="查看CPU是否支持虚拟化"></a>查看CPU是否支持虚拟化</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">egrep -c <span class="string">&#x27;(vmx|svm)&#x27;</span> /proc/cpuinfo</span><br></pre></td></tr></table></figure>
<p>如果 <code>&gt;0</code>则支持</p>
<p>然后在 BIOS 中开启 <code>enable  VT</code>和<code>Intel VT-d</code></p>
<h3 id="启用IOMMU"><a href="#启用IOMMU" class="headerlink" title="启用IOMMU"></a>启用<code>IOMMU</code></h3><p>修改<code>/etc/default/grub</code><br>在<code>GRUB_CMDLINE_LINUX</code>后面添加<code>intel_iommu=on</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GRUB_CMDLINE_LINUX=<span class="string">&quot;crashkernel=auto biosdevname=0 net.ifnames=0 rhgb quiet intel_iommu=on&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后生成引导&amp;重启</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">grub2-mkconfig  -o /boot/grub2/grub.cfg</span><br><span class="line">reboot now</span><br></pre></td></tr></table></figure>

<p>重启后检查<code>IOMMU</code>是否启用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# dmesg | grep -e DMAR -e IOMMU</span><br><span class="line">...</span><br><span class="line">[    0.000000] DMAR: IOMMU enabled</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="查看网卡支持虚拟的数量"><a href="#查看网卡支持虚拟的数量" class="headerlink" title="查看网卡支持虚拟的数量"></a>查看网卡支持虚拟的数量</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat /sys/class/net/eth0/device/sriov_totalvfs</span><br></pre></td></tr></table></figure>

<h3 id="创建虚拟网卡"><a href="#创建虚拟网卡" class="headerlink" title="创建虚拟网卡"></a>创建虚拟网卡</h3><p>以<code>eth0</code>为例</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;7&#x27;</span> &gt; /sys/class/net/eth0/device/sriov_numvfs</span><br></pre></td></tr></table></figure>
<p>然后检查是否创建成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# lspci|grep Ethernet</span><br><span class="line">01:00.0 Ethernet controller: Intel Corporation I350 Gigabit Network Connection (rev 01)</span><br><span class="line">01:00.1 Ethernet controller: Intel Corporation I350 Gigabit Network Connection (rev 01)</span><br><span class="line">01:10.0 Ethernet controller: Intel Corporation I350 Ethernet Controller Virtual Function (rev 01)</span><br><span class="line">01:10.4 Ethernet controller: Intel Corporation I350 Ethernet Controller Virtual Function (rev 01)</span><br><span class="line">01:11.0 Ethernet controller: Intel Corporation I350 Ethernet Controller Virtual Function (rev 01)</span><br><span class="line">01:11.4 Ethernet controller: Intel Corporation I350 Ethernet Controller Virtual Function (rev 01)</span><br><span class="line">01:12.0 Ethernet controller: Intel Corporation I350 Ethernet Controller Virtual Function (rev 01)</span><br><span class="line">01:12.4 Ethernet controller: Intel Corporation I350 Ethernet Controller Virtual Function (rev 01)</span><br><span class="line">01:13.0 Ethernet controller: Intel Corporation I350 Ethernet Controller Virtual Function (rev 01)</span><br></pre></td></tr></table></figure>

<p>这个配置非持久化</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>sr-iov</tag>
      </tags>
  </entry>
  <entry>
    <title>cert</title>
    <url>/posts/caa206b.html</url>
    <content><![CDATA[<h2 id="证书内容"><a href="#证书内容" class="headerlink" title="证书内容"></a>证书内容</h2><p>常用就是<code>x509</code> 解证书看内容</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl x509 -noout -<span class="keyword">in</span> ca.cer -text</span><br></pre></td></tr></table></figure>

<p>其他的证书生成，走 <code>cfssl</code> 工具</p>
<h2 id="Let’s-Encrypt-DNS-模式认证"><a href="#Let’s-Encrypt-DNS-模式认证" class="headerlink" title="Let’s Encrypt DNS 模式认证"></a>Let’s Encrypt DNS 模式认证</h2><a id="more"></a>
<p>DNS 模式验证签发证书可以完美避开<code>80</code>端口限制<br>原理就是添加一条TXT记录，验证域名所有权</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl  https://get.acme.sh | sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /root/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> Ali_Key=<span class="string">&quot;AK&quot;</span></span><br><span class="line"><span class="built_in">export</span> Ali_Secret=<span class="string">&quot;SK&quot;</span></span><br><span class="line"><span class="comment"># 签发</span></span><br><span class="line">acme.sh --issue  --dns dns_ali -d <span class="string">&#x27;www.example.com&#x27;</span> -d <span class="string">&#x27;example.com&#x27;</span> --yes-I-know-dns-manual-mode-enough-go-ahead-please</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后面定期更新</span></span><br><span class="line">acme.sh --renew  --dns dns_ali -d <span class="string">&#x27;www.example.com&#x27;</span> -d <span class="string">&#x27;example.com&#x27;</span> --yes-I-know-dns-manual-mode-enough-go-ahead-please</span><br></pre></td></tr></table></figure>

<blockquote>
<p>DNS 部分需要对接不同服务的API,我这里用着aliyun 的<br>其他可以参考 <a href="https://github.com/acmesh-official/acme.sh/wiki/dnsapi">https://github.com/acmesh-official/acme.sh/wiki/dnsapi</a></p>
</blockquote>
]]></content>
      <categories>
        <category>cheatbook</category>
      </categories>
      <tags>
        <tag>cert</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/posts/69c3279c.html</url>
    <content><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="密码中特殊字符"><a href="#密码中特殊字符" class="headerlink" title="密码中特殊字符"></a>密码中特殊字符</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">!   <span class="comment">#   $    &amp;   &#x27;   (   )   *   +   ,   /   :   ;   =   ?   @   [   ]</span></span><br><span class="line">%21 %23 %24 %26 %27 %28 %29 %2A %2B %2C %2F %3A %3B %3D %3F %40 %5B %5D</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># http</span></span><br><span class="line">git config --global http.proxy http://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy http://127.0.0.1:1080</span><br><span class="line"></span><br><span class="line"><span class="comment"># socks5</span></span><br><span class="line">git config --global http.proxy <span class="string">&quot;socks5://127.0.0.1:1080&quot;</span></span><br><span class="line">git config --global https.proxy <span class="string">&quot;socks5://127.0.0.1:1080&quot;</span></span><br><span class="line"></span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br><span class="line"></span><br><span class="line"><span class="comment"># ssh</span></span><br><span class="line">tee ~/.ssh/config&lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">Host github.com</span></span><br><span class="line"><span class="string">    ProxyCommand connect -H 127.0.0.1:1080 %h 22</span></span><br><span class="line"><span class="string">    ServerAliveInterval  10</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<h1 id="config"><a href="#config" class="headerlink" title="config"></a>config</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 意思是 提交时 CRLF 转 LF</span></span><br><span class="line">git config --global core.autocrlf input</span><br><span class="line">git config --global http.sslVerify <span class="literal">false</span></span><br><span class="line">git config --global user.name <span class="string">&quot;user&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;email&quot;</span></span><br><span class="line">git config --global help.format man</span><br></pre></td></tr></table></figure>

<h1 id="key"><a href="#key" class="headerlink" title="key"></a>key</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;email&quot;</span> -b 4096</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cheatbook</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 python 处理 excel</title>
    <url>/posts/22037f37.html</url>
    <content><![CDATA[<p>本文旨在记录对excel 常用操作方式</p>
<a id="more"></a>

<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><table>
<thead>
<tr>
<th>包</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>xlrd</td>
<td>读取</td>
</tr>
<tr>
<td>xlwt</td>
<td>写入</td>
</tr>
<tr>
<td>xlutils</td>
<td>配合xlrd做编辑</td>
</tr>
</tbody></table>
<h2 id="创建excel"><a href="#创建excel" class="headerlink" title="创建excel"></a>创建excel</h2><p>最简单的例子就是创建一个sheet页的文档</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"></span><br><span class="line">wb = xlwt.Workbook(encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">sheet = wb.add_sheet(<span class="string">&quot;sheet1&quot;</span>)</span><br><span class="line">wb.save(<span class="string">&quot;excel.xls&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="cell-操作"><a href="#cell-操作" class="headerlink" title="cell 操作"></a>cell 操作</h3><p>每个sheet 都是一个二维表，通过 (x,y) 这样的索引对单元格（cell）进行操作</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符</span></span><br><span class="line">sheet.write(<span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;string&quot;</span>)</span><br><span class="line"><span class="comment"># 数值</span></span><br><span class="line">sheet.write(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1024</span>)</span><br><span class="line"><span class="comment"># 布尔</span></span><br><span class="line">sheet.write(<span class="number">0</span>, <span class="number">3</span>, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间/日期</span></span><br><span class="line">selfFormat = xlwt.XFStyle()</span><br><span class="line">selfFormat.num_format_str = <span class="string">&#x27;yyyy-mm-dd hh:mm:ss&#x27;</span></span><br><span class="line">sheet.write(<span class="number">0</span>, <span class="number">4</span>, datetime.datetime.now(), selfFormat)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在excel中日期、时间是以浮点数存储的，<code>1 = 1900/1/1 0:00:00</code> ，并且每一天+1，时间折算到小数</p>
</blockquote>
<h3 id="设置单元格样式"><a href="#设置单元格样式" class="headerlink" title="设置单元格样式"></a>设置单元格样式</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建字体</span></span><br><span class="line">font = xlwt.Font()</span><br><span class="line">font.name = <span class="string">&quot;Arial&quot;</span></span><br><span class="line">font.bold = <span class="literal">True</span></span><br><span class="line">font.color_index = <span class="number">4</span></span><br><span class="line"><span class="comment"># font.height =</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对齐方式</span></span><br><span class="line">align = xlwt.Alignment()</span><br><span class="line">align.horz = xlwt.Alignment.HORZ_CENTER</span><br><span class="line">align.vert = xlwt.Alignment.VERT_CENTER</span><br><span class="line"></span><br><span class="line">style = xlwt.XFStyle()</span><br><span class="line">style.font = font</span><br><span class="line">style.alignment = align</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置合并</span></span><br><span class="line"><span class="comment"># 参数：起始行,结束行,起始列,结束列</span></span><br><span class="line">sheet.write_merge(<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;合并单元格&quot;</span>, style)</span><br></pre></td></tr></table></figure>

<h2 id="读取excel"><a href="#读取excel" class="headerlink" title="读取excel"></a>读取excel</h2><p>读取需要使用 xlrd ，不能对内容进行修改</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开xls文件</span></span><br><span class="line">wb = xlrd.open_workbook(<span class="string">&quot;excel.xls&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取sheet 可以通过index 或者name 进行索引</span></span><br><span class="line">sheet_names = wb.sheet_names()</span><br><span class="line">sheet = wb.sheet_by_index(<span class="number">0</span>)</span><br><span class="line">sheet = wb.sheet_by_name(<span class="string">u&#x27;Sheet1&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 要是处理全部表格的化可以直接遍历</span></span><br><span class="line">sheets = wb.sheets()</span><br><span class="line"><span class="keyword">for</span> sheet <span class="keyword">in</span> sheets:</span><br><span class="line">    <span class="comment"># 获取总行列数</span></span><br><span class="line">    print(<span class="string">&quot;Sheet: %8s Rows: %2s Cols: %2s&quot;</span> % (sheet.name, sheet.nrows, sheet.ncols))</span><br><span class="line">    <span class="comment"># 获取第0行的前10列</span></span><br><span class="line">    sheet.row_values(<span class="number">0</span>)[:<span class="number">10</span>]</span><br><span class="line">    <span class="comment"># 获取一列</span></span><br><span class="line">    sheet.col_values(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取单元格</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(sheet.nrows):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(sheet.ncols):</span><br><span class="line">            <span class="comment"># 判断单元格类型</span></span><br><span class="line">            <span class="keyword">if</span> sheet.cell_type(i, j) == xlrd.XL_CELL_TEXT:</span><br><span class="line">                print(<span class="string">&quot;Type: TEXT Value: %s&quot;</span> % sheet.cell(i, j).value)</span><br><span class="line">            <span class="keyword">if</span> sheet.cell_type(i, j) == xlrd.XL_CELL_BOOLEAN:</span><br><span class="line">                print(<span class="string">&quot;Type: BOOLEAN Value: %r&quot;</span> % sheet.cell(i, j).value)</span><br><span class="line">            <span class="keyword">if</span> sheet.cell_type(i, j) == xlrd.XL_CELL_NUMBER:</span><br><span class="line">                print(<span class="string">&quot;Type: NUMBER Value: %f&quot;</span> % sheet.cell(i, j).value)</span><br><span class="line">            <span class="keyword">if</span> sheet.cell_type(i, j) == xlrd.XL_CELL_DATE:</span><br><span class="line">                <span class="comment"># 时间类型处理需要确定excel 起始时间，在这里是 1900</span></span><br><span class="line">                <span class="comment"># xldate_as_datetime : 0: 1900-based, 1: 1904-based.</span></span><br><span class="line">                print(<span class="string">&quot;Type: DATE Value: %r&quot;</span> % xlrd.xldate.xldate_as_datetime(sheet.cell(i, j).value, <span class="number">0</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="编辑excel"><a href="#编辑excel" class="headerlink" title="编辑excel"></a>编辑excel</h2><p>需要再加 xlutils 包</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">from</span> xlutils.copy <span class="keyword">import</span> copy</span><br><span class="line">wb = copy(xlrd.open_workbook(<span class="string">&quot;excel.xls&quot;</span>))</span><br><span class="line">sheet = wb.get_sheet(<span class="number">0</span>)</span><br><span class="line">sheet.set_name(<span class="string">&quot;copyed_%s&quot;</span> % sheet.get_name())</span><br><span class="line">wb.add_sheet(<span class="string">&quot;sheet2&quot;</span>)</span><br><span class="line">wb.save(<span class="string">&#x27;new_excel.xls&#x27;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>copy 方法只会拷贝数据，所有样式都会丢失</p>
</blockquote>
]]></content>
      <categories>
        <category>cheatbook</category>
      </categories>
      <tags>
        <tag>excel</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Homebrew 安装简介</title>
    <url>/posts/c2f072ca.html</url>
    <content><![CDATA[<p>官网 <a href="http://brew.sh/index_zh-cn.html">http://brew.sh/index_zh-cn.html</a></p>
<a id="more"></a>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Homebrew: 软件包管理<br>Homebrew-Core: 核心软件仓库<br>Homebrew-Cask: macOS 应用和大型二进制文件<br>Homebrew-Bottles: 预编译二进制软件包</p>
<ul>
<li>homebrew/homebrew-core</li>
<li>homebrew/homebrew-dupes</li>
<li>homebrew/homebrew-php</li>
<li>homebrew/homebrew-science</li>
<li>homebrew/homebrew-nginx</li>
<li>homebrew/homebrew-apache</li>
<li>homebrew/homebrew-portable</li>
</ul>
<h2 id="安装Homebrew"><a href="#安装Homebrew" class="headerlink" title="安装Homebrew"></a>安装Homebrew</h2><p>homebrew主要分两部分：git repo（位于GitHub）和二进制bottles（位于bintray）<br>由于你懂的安装、更新一直很慢，提供两种方法，我更喜欢 proxy，这种配置更为方便～</p>
<h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><p>proxy 方法安装比较方便，在拉取仓库时设置proxy，会显著提高速度</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config --global https.proxy http://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy https://127.0.0.1:1080</span><br><span class="line">/usr/bin/ruby -e <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>&quot;</span>`</span><br></pre></td></tr></table></figure>

<h3 id="修改安装脚本"><a href="#修改安装脚本" class="headerlink" title="修改安装脚本"></a>修改安装脚本</h3><p>修改脚本主要将github的源换成镜像的地址，方便无proxy的用户</p>
<p>install 为自修改后的内容</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e <span class="string">&quot;<span class="subst">$(curl -fsSL https://gist.githubusercontent.com/l1b0k/329b70a22a469a5f73d6a292005ef9da/raw/b3318d9568229f07407b6cb84ba24fecd75785b5/install)</span>&quot;</span>`</span><br></pre></td></tr></table></figure>

<p>👇是具体分析过程</p>
<hr>
<p>将<a href="%60https://raw.githubusercontent.com/Homebrew/install/master/install%60">脚本</a>下载到本地，并且编辑、保存</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">HOMEBREW_PREFIX = &quot;/usr/local&quot;.freeze</span><br><span class="line">HOMEBREW_REPOSITORY = &quot;/usr/local/Homebrew&quot;.freeze</span><br><span class="line">HOMEBREW_CACHE = &quot;#&#123;ENV[&quot;HOME&quot;]&#125;/Library/Caches/Homebrew&quot;.freeze</span><br><span class="line">HOMEBREW_OLD_CACHE = &quot;/Library/Caches/Homebrew&quot;.freeze</span><br><span class="line"><span class="deletion">- BREW_REPO = &quot;https://github.com/Homebrew/brew&quot;.freeze</span></span><br><span class="line"><span class="addition">+ BREW_REPO = &quot;https://mirrors.ustc.edu.cn/brew.git&quot;.freeze</span></span><br><span class="line">CORE_TAP_REPO = &quot;https://github.com/Homebrew/homebrew-core&quot;.freeze</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>⚠️！<code>CORE_TAP_REPO</code> 在这里修改是无效的（已经有git的用户，这个代码逻辑走不到。。）<br>在安装脚本大约311 行，会调用update指令，调用时会初始化<code>/usr/local/Homebrew/Library/Tap</code>，这时brew就会自动更新<code>homebrew-core</code>，导致直接连接github去更新…</p>
<p>处理办法为主动设置仓库地址：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">    system git, &quot;reset&quot;, &quot;--hard&quot;, &quot;origin/master&quot;</span><br><span class="line"></span><br><span class="line">    system &quot;ln&quot;, &quot;-sf&quot;, &quot;#&#123;HOMEBREW_REPOSITORY&#125;/bin/brew&quot;, &quot;#&#123;HOMEBREW_PREFIX&#125;/bin/brew&quot;</span><br><span class="line"></span><br><span class="line"><span class="addition">+ 	core_tap = &quot;#&#123;HOMEBREW_PREFIX&#125;/Homebrew/Library/Taps/homebrew/homebrew-core&quot;</span></span><br><span class="line"><span class="addition">+ 	system &quot;/bin/mkdir&quot;, &quot;-p&quot;, core_tap</span></span><br><span class="line"><span class="addition">+ 	</span></span><br><span class="line"><span class="addition">+ 	Dir.chdir core_tap do</span></span><br><span class="line"><span class="addition">+ 		system git, &quot;init&quot;, &quot;-q&quot;</span></span><br><span class="line"><span class="addition">+ 		system git, &quot;config&quot;, &quot;remote.origin.url&quot;, + &quot;https://mirrors.ustc.edu.cn/homebrew-core.git&quot;</span></span><br><span class="line"><span class="addition">+ 	    system git, &quot;config&quot;, &quot;remote.origin.fetch&quot;, &quot;+refs/heads/*:refs/remotes/origin/*&quot;</span></span><br><span class="line"><span class="addition">+ 	    system git, &quot;config&quot;, &quot;core.autocrlf&quot;, &quot;false&quot;</span></span><br><span class="line"><span class="addition">+ 	    args = git, &quot;fetch&quot;, &quot;origin&quot;, &quot;master:refs/remotes/origin/master&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;--tags&quot;, &quot;--force&quot;</span></span><br><span class="line"><span class="addition">+     	system(*args)</span></span><br><span class="line"><span class="addition">+ </span></span><br><span class="line"><span class="addition">+     	system git, &quot;reset&quot;, &quot;--hard&quot;, &quot;origin/master&quot;</span></span><br><span class="line"><span class="addition">+ 	end</span></span><br><span class="line">	</span><br><span class="line">    system &quot;#&#123;HOMEBREW_PREFIX&#125;/bin/brew&quot;, &quot;update&quot;, &quot;--force&quot;</span><br></pre></td></tr></table></figure>


<p>然后执行安装，期间要输入账户密码，经过几分钟就完成安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  Downloads /usr/bin/ruby install</span><br><span class="line">==&gt; This script will install:</span><br><span class="line">/usr/<span class="built_in">local</span>/bin/brew</span><br><span class="line">/usr/<span class="built_in">local</span>/share/doc/homebrew</span><br><span class="line">/usr/<span class="built_in">local</span>/share/man/man1/brew.1</span><br><span class="line">/usr/<span class="built_in">local</span>/share/zsh/site-functions/_brew</span><br><span class="line">/usr/<span class="built_in">local</span>/etc/bash_completion.d/brew</span><br><span class="line">/usr/<span class="built_in">local</span>/Homebrew</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">==&gt; Next steps:</span><br><span class="line">- Run `brew <span class="built_in">help</span>` to get started</span><br><span class="line">- Further documentation: </span><br><span class="line">    https://docs.brew.sh</span><br><span class="line">➜  Downloads </span><br></pre></td></tr></table></figure>


<h3 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h3><p>无论👆哪种安装方式都可以再执行下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 替换brew</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>&quot;</span></span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/brew.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换homebrew-core</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core&quot;</span></span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换bottles</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>


<blockquote>
<p>上面使用了zsh，bash请把<code>~/.zshrc</code>改为 <code>~/.bash_profile</code></p>
</blockquote>
<h3 id="恢复源"><a href="#恢复源" class="headerlink" title="恢复源"></a>恢复源</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重置brew</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>&quot;</span></span><br><span class="line">git remote set-url origin https://github.com/Homebrew/brew.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置homebrew-core</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core&quot;</span></span><br><span class="line">git remote set-url origin https://github.com/Homebrew/homebrew-core.git</span><br></pre></td></tr></table></figure>

<h2 id="brew-常用指令"><a href="#brew-常用指令" class="headerlink" title="brew 常用指令"></a>brew 常用指令</h2><p>⚠️使用前顺手关闭分析跟踪<br><code>brew analytics off</code></p>
<p>更新brew自身<br><code>brew update</code></p>
<p>列出过时的软件包（已安装但不是最新版本）<br><code>brew outdated</code></p>
<p>更新过时的软件包（不跟包名就是更新所有包）<br><code>brew upgrade package_name</code></p>
<p>验证brew是否安装成功（也可以用来检查无效的包和依赖关系有问题的包）<br><code>brew doctor</code></p>
<p>查看软件包信息<br><code>brew info package_name</code></p>
<p>查找软件包<br><code>brew search package_name</code></p>
<p>安装软件包<br><code>brew install package_name</code></p>
<p>卸载软件<br><code>brew uninstall package_name</code></p>
<p>列出已安装的软件包<br><code>brew list</code></p>
<p>列出安装包的内容<br><code>brew list package_name</code></p>
<p>列出软件包的依赖关系<br><code>brew deps package_name</code></p>
<p>列出brew常用命令<br><code>brew help</code></p>
<p>卸载除go 之外的包<br><code>ls /usr/local/Cellar/ |grep -v go| xargs brew uninstall --ignore-dependencies</code></p>
<p>清理过时包和缓存<br><code>brew cleanup</code></p>
<h2 id="10-12-权限修复-Deprecated"><a href="#10-12-权限修复-Deprecated" class="headerlink" title="10.12 权限修复(@Deprecated)"></a>10.12 权限修复(@Deprecated)</h2><p>升级 10.12 Sierra 之后运行 <code>brew update</code>会报 <code>/usr/local</code> 无权写入<br>10.12 之前 brew 使用 /usr/local 作为主目录，目录所有者是 user<br>更新10.12之后 <code>/usr/local</code> 这个目录所有者变成了 root<br>Fix:<br><code>sudo chown $(whoami):admin /usr/local</code></p>
<p>之后再运行 <code>brew update</code> 就能正常运行，同时 Homebrew 已经提供对 10.12的支持，更新后主目录迁移到 <code>/usr/local/Homebrew</code> ，现在再把权限改回来</p>
<p><code>sudo chown root:wheel /usr/local</code></p>
<h2 id="使用扩展源-caskroom"><a href="#使用扩展源-caskroom" class="headerlink" title="使用扩展源(caskroom)"></a>使用扩展源(caskroom)</h2><p>brew 使用 tap 命令来处理软件源<br><code>homebrew/core</code> 是默认的源，装完就能看到</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  ~ brew tap</span><br><span class="line">homebrew/core</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/caskroom/homebrew-cask">caskroom</a> 会包含其他商业的软件</p>
<ul>
<li>java</li>
<li>goland</li>
<li>atom</li>
<li>intellij-idea</li>
<li>google-chrome</li>
<li>mpv</li>
</ul>
<p><a href="https://github.com/caskroom/homebrew-versions">caskroom/version</a>包含历史版本</p>
<ul>
<li>java8</li>
</ul>
<h3 id="安装与换源"><a href="#安装与换源" class="headerlink" title="安装与换源"></a>安装与换源</h3><p>通过<code>brew tap caskroom/cask</code> 就可以添加</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  ~ brew tap caskroom/cask</span><br><span class="line">==&gt; Tapping caskroom/cask</span><br><span class="line">Cloning into <span class="string">&#x27;/usr/local/Homebrew/Library/Taps/caskroom/homebrew-cask&#x27;</span>...</span><br><span class="line">...</span><br><span class="line">➜  ~ brew tap</span><br><span class="line">caskroom/cask</span><br><span class="line">homebrew/core</span><br></pre></td></tr></table></figure>

<p>执行tap时，就会拉取仓库，如果嫌慢可以手动创建路径，配置镜像仓库（过程略）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 替换 homebrew-cask</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>&quot;</span>/Library/Taps/caskroom/homebrew-cask</span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复 homebrew-cask</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>&quot;</span>/Library/Taps/caskroom/homebrew-cask</span><br><span class="line">git remote set-url origin https://github.com/caskroom/homebrew-cask.git</span><br></pre></td></tr></table></figure>

<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><code>brew cask install goland</code></p>
<p><code>brew cask uninstall goland</code></p>
]]></content>
      <categories>
        <category>cheatbook</category>
      </categories>
      <tags>
        <tag>homebrew</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>python</title>
    <url>/posts/a4d4b8b8.html</url>
    <content><![CDATA[<h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1><h2 id="pip-源"><a href="#pip-源" class="headerlink" title="pip 源"></a>pip 源</h2><p>linux </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/.pip</span><br><span class="line">tee ~/.pip/pip.conf&lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">[global]</span></span><br><span class="line"><span class="string">index-url=https://mirrors.aliyun.com/pypi/simple/</span></span><br><span class="line"><span class="string">trusted-host=mirrors.aliyun.com</span></span><br><span class="line"><span class="string">[install]</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>windows</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/pip</span><br><span class="line">tee ~/pip/pip.ini&lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">[global]</span></span><br><span class="line"><span class="string">index-url=https://mirrors.aliyun.com/pypi/simple/</span></span><br><span class="line"><span class="string">trusted-host=mirrors.aliyun.com</span></span><br><span class="line"><span class="string">[install]</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cheatbook</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorflow 环境搭建</title>
    <url>/posts/644beb87.html</url>
    <content><![CDATA[<p>本文记录了参照<a href="https://www.tensorflow.org/install/install_windows">官方文档</a>，在windows上安装tensorflow，并且开启gpu加速</p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>Windows10<br>GTX 1070</p>
<a id="more"></a>
<h2 id="安装后各组件版本"><a href="#安装后各组件版本" class="headerlink" title="安装后各组件版本"></a>安装后各组件版本</h2><p>Python 3.6.4<br>tensorflow 1.5.0<br>CUDA Toolkit 9.0<br>cuDNN v7.0.5 </p>
<h1 id="安装-Anaconda"><a href="#安装-Anaconda" class="headerlink" title="安装 Anaconda"></a>安装 Anaconda</h1><p><a href="https://www.continuum.io/downloads">https://www.continuum.io/downloads</a><br>选择Python 3.6 的版本，下载后默认配置安装</p>
<blockquote>
<p>安装完成可以注销下，使得环境变量生效</p>
</blockquote>
<p>##创建venv</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">conda create -n tensorflow pip python=3.6</span><br></pre></td></tr></table></figure>

<h2 id="激活venv-amp-安装"><a href="#激活venv-amp-安装" class="headerlink" title="激活venv &amp; 安装"></a>激活venv &amp; 安装</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">activate tensorflow</span><br><span class="line">pip install --ignore-installed --upgrade tensorflow-gpu</span><br></pre></td></tr></table></figure>

<p>安装完成后，可以看下当前tf的版本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(tensorflow) D:\&gt;pip list</span><br><span class="line"></span><br><span class="line">tensorflow-gpu (1.5.0)</span><br><span class="line">tensorflow-tensorboard (1.5.1)</span><br></pre></td></tr></table></figure>

<h2 id="安装cuda-amp-cuDNN"><a href="#安装cuda-amp-cuDNN" class="headerlink" title="安装cuda &amp; cuDNN"></a>安装cuda &amp; cuDNN</h2><p>tf 1.5 版本支持的cuda 版本为 9.0 （9.1是不行的），cuDNN 版本为7 （不是官方文档里的6)</p>
<h3 id="CUDA"><a href="#CUDA" class="headerlink" title="CUDA"></a>CUDA</h3><p><code>https://developer.nvidia.com/cuda-90-download-archive</code></p>
<p>下载后为可执行文件，使用默认配置安装即可。</p>
<h3 id="cuDNN"><a href="#cuDNN" class="headerlink" title="cuDNN"></a>cuDNN</h3><p>下载需要先注册<br><code>https://developer.nvidia.com/rdp/cudnn-download</code></p>
<p>选择<code>Download cuDNN v7.0.5 (Dec 5, 2017), for CUDA 9.0</code><br>下载<br>cudnn-9.0-windows10-x64-v7.zip</p>
<p>下载后找一个路径解压，将 <code>bin</code>文件路径配置到系统<code>PATH</code>里面(配置环境变量)</p>
<h1 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先激活venv</span></span><br><span class="line">C:\Users\u&gt;activate tensorflow</span><br><span class="line">(tensorflow) C:\Users\u&gt;python</span><br><span class="line">Python 3.6.4 |Anaconda, Inc.| (default, Jan 16 2018, 10:22:32) [MSC v.1900 64 bit (AMD64)] on win32</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> or <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt; import tensorflow as tf</span><br><span class="line">&gt;&gt;&gt; hello = tf.constant(<span class="string">&#x27;Hello, TensorFlow!&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt; sess = tf.Session()</span><br><span class="line">2018-02-17 13:29:11.026439: I C:\tf_jenkins\workspace\rel-win\M\windows-gpu\PY\36\tensorflow\core\platform\cpu_feature_guard.cc:137] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX AVX2</span><br><span class="line">2018-02-17 13:29:11.322431: I C:\tf_jenkins\workspace\rel-win\M\windows-gpu\PY\36\tensorflow\core\common_runtime\gpu\gpu_device.cc:1105] Found device 0 with properties:</span><br><span class="line">name: GeForce GTX 1070 major: 6 minor: 1 memoryClockRate(GHz): 1.7845</span><br><span class="line">pciBusID: 0000:01:00.0</span><br><span class="line">totalMemory: 8.00GiB freeMemory: 6.63GiB</span><br><span class="line">2018-02-17 13:29:11.326018: I C:\tf_jenkins\workspace\rel-win\M\windows-gpu\PY\36\tensorflow\core\common_runtime\gpu\gpu_device.cc:1195] Creating TensorFlow device (/device:GPU:0) -&gt; (device: 0, name: GeForce GTX 1070, pci bus id: 0000:01:00.0, compute capability: 6.1)</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(sess.run(hello))</span><br><span class="line">b<span class="string">&#x27;Hello, TensorFlow!&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>至此安装完成~ To be continued.</p>
]]></content>
      <categories>
        <category>cheatbook</category>
      </categories>
      <tags>
        <tag>tensorflow</tag>
        <tag>tf</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 中 error 处理</title>
    <url>/posts/dc0f73fa.html</url>
    <content><![CDATA[<h2 id="创建error"><a href="#创建error" class="headerlink" title="创建error"></a>创建error</h2><p>通常在golang中用下面方式创建error</p>
<h3 id="1-fmt-Errorf"><a href="#1-fmt-Errorf" class="headerlink" title="1. fmt.Errorf"></a>1. fmt.Errorf</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">action</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;sth went wrong&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="2-errors-New"><a href="#2-errors-New" class="headerlink" title="2. errors.New"></a>2. errors.New</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">action</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.New(<span class="string">&quot;sth went wrong&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-实现error-接口"><a href="#3-实现error-接口" class="headerlink" title="3. 实现error 接口"></a>3. 实现error 接口</h3><p>上面两种创建方式都是使用 errors 进行创建的<br>errors 实现了 error 接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">	Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们需要自定义error 的类型，就需要实现 error 接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">	Msg <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e MyError)</span><span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> e.Msg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编写约定"><a href="#编写约定" class="headerlink" title="编写约定"></a>编写约定</h2><p>golang 约定了error中的string：首母小写，结尾不带标点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := errors.New(<span class="string">&quot;sth went wrong&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;The returned error is %s.\n&quot;</span>, err)</span><br></pre></td></tr></table></figure>

<h2 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h2><h3 id="是否有异常"><a href="#是否有异常" class="headerlink" title="是否有异常"></a>是否有异常</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="comment">//handle error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="是否有特定的异常"><a href="#是否有特定的异常" class="headerlink" title="是否有特定的异常"></a>是否有特定的异常</h3><p>通常在程序中会自定义一系列的异常，方便细化处理</p>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/os/error.go</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ErrInvalid    = errors.New(<span class="string">&quot;invalid argument&quot;</span>)</span><br><span class="line">    ErrPermission = errors.New(<span class="string">&quot;permission denied&quot;</span>)</span><br><span class="line">    ErrExist      = errors.New(<span class="string">&quot;file already exists&quot;</span>)</span><br><span class="line">    ErrNotExist   = errors.New(<span class="string">&quot;file does not exist&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果os 包的方法有异常，就可以直接进行比较</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err == os.ErrInvalid &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现error-接口"><a href="#实现error-接口" class="headerlink" title="实现error 接口"></a>实现error 接口</h4><p>当需要记录更多异常信息时就要自己实现error 接口<br>这种情况下可以用类型判断来区分error<br>下面是个🌰</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">	Msg <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e MyError)</span><span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> e.Msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SomeFunc 会return error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SomeFunc</span><span class="params">()</span> <span class="title">error</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> MyError&#123;<span class="string">&quot;bad things happen&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := SomeFunc()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 switch</span></span><br><span class="line">	<span class="keyword">switch</span> err.(<span class="keyword">type</span>)&#123;</span><br><span class="line">	<span class="keyword">case</span> MyError:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;MyErr: &quot;</span> + err.Error())</span><br><span class="line">	<span class="keyword">case</span> error:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;error: &quot;</span> + err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 assert</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := err.(MyError); ok &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;TypeAssert: &quot;</span> + err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>cheatbook</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>浙江电信 IPTV 单线复用</title>
    <url>/posts/8b55cd7.html</url>
    <content><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ul>
<li>单线复用</li>
<li>客厅轻度 IPTV 使用，无其他设备观看需求</li>
</ul>
<h2 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h2><ul>
<li>HG6201T</li>
<li>RT-AC86U</li>
</ul>
<p>HG6201T 光猫超级密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">telecomadmin</span><br><span class="line">telecomadmin90857137</span><br></pre></td></tr></table></figure>

<h2 id="光猫配置"><a href="#光猫配置" class="headerlink" title="光猫配置"></a>光猫配置</h2><p><code>网口1</code> 单线复用 internet + iptv</p>
<ol>
<li>取消 LAN 端口绑定</li>
</ol>
<p>internet</p>
<img src="/posts/8b55cd7/lan_internet.png" class="">

<p>iptv</p>
<img src="/posts/8b55cd7/lan_iptv.png" class="">

<ol start="2">
<li>vlan 绑定</li>
</ol>
<p>只绑定 iptv 的 vlan 到网口1</p>
<img src="/posts/8b55cd7/vlan_bind.png" class="">

<blockquote>
<p>其他文章里说的同时绑定 internet和iptv 的vlan 实际试验失败<br>  看起来应该是挂两个不同的 vlan 下，但是 86u 同步配置 VID 后是不行的，原因没再分析了</p>
</blockquote>
<ol start="3">
<li>组播</li>
</ol>
<p>组播没改配置，已经开启了 <code>IGMPSnooping</code></p>
<img src="/posts/8b55cd7/igmp.png" class="">

<h2 id="AC86U-配置"><a href="#AC86U-配置" class="headerlink" title="AC86U 配置"></a>AC86U 配置</h2><ol>
<li>光猫网口1 连接86u 的wan 口</li>
<li>在 IPTV 配置中，只配置 IPTV 的 <code>VID 43</code>，不配置 internet</li>
</ol>
<img src="/posts/8b55cd7/86u_iptv.png" class="">

<blockquote>
<p>86U 这块后台配置没什么文档，实在搞不清怎么接入的，上述配置存粹试出来的。。</p>
</blockquote>
<h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>重启两个设备即可</p>
<p>简单观察了下 86U 没什么负载，一切都好</p>
]]></content>
      <categories>
        <category>home-network</category>
      </categories>
      <tags>
        <tag>iptv</tag>
      </tags>
  </entry>
  <entry>
    <title>在 K8S 中使用 IP SAN 设备</title>
    <url>/posts/f039165f.html</url>
    <content><![CDATA[<h2 id="TOC"><a href="#TOC" class="headerlink" title="TOC"></a>TOC</h2><ul>
<li>IP SAN 设备配置简介</li>
<li>CentOS 7 使用 iSCSI 连接设备</li>
<li>K8S 使用 iSCSI 作为pv后端</li>
<li>CentOS 7 使用 NFS 连接设备</li>
<li>K8S 使用 NFS 作为pv后端</li>
</ul>
<a id="more"></a>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><table>
<thead>
<tr>
<th>缩写</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>iSCSI</td>
<td>Internet Small Computer System Interface</td>
</tr>
<tr>
<td>IQN</td>
<td>iSCSI Qualified Name</td>
</tr>
<tr>
<td>NFS</td>
<td>Network File System</td>
</tr>
</tbody></table>
<h2 id="IP-SAN-设备配置简介"><a href="#IP-SAN-设备配置简介" class="headerlink" title="IP SAN 设备配置简介"></a>IP SAN 设备配置简介</h2><p>IP SAN 配置略<br>本文主要探究 iSCSI、NFS两种协议的使用方式</p>
<h3 id="k8s-对存储的支持情况"><a href="#k8s-对存储的支持情况" class="headerlink" title="k8s 对存储的支持情况"></a>k8s 对存储的支持情况</h3><table>
<thead>
<tr>
<th align="left">Volume Plugin</th>
<th align="center">ReadWriteOnce</th>
<th align="center">ReadOnlyMany</th>
<th align="center">ReadWriteMany</th>
</tr>
</thead>
<tbody><tr>
<td align="left">HostPath</td>
<td align="center">&#x2713;</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="left">iSCSI</td>
<td align="center">&#x2713;</td>
<td align="center">&#x2713;</td>
<td align="center">-</td>
</tr>
<tr>
<td align="left">NFS</td>
<td align="center">&#x2713;</td>
<td align="center">&#x2713;</td>
<td align="center">&#x2713;</td>
</tr>
</tbody></table>
<p>NFS 相对支持比较好点，支持多读多写，推荐使用</p>
<h2 id="CentOS-7-使用-iSCSI-连接设备"><a href="#CentOS-7-使用-iSCSI-连接设备" class="headerlink" title="CentOS 7 使用 iSCSI 连接设备"></a>CentOS 7 使用 iSCSI 连接设备</h2><p>首先安装 iSCSI 控制器</p>
<p><code>yum install iscsi-initiator-utils -y</code></p>
<h3 id="搜索设备"><a href="#搜索设备" class="headerlink" title="搜索设备"></a>搜索设备</h3><p>搜索下设备，找到 IQN</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master1 ~]# iscsiadm -m discoverydb -t sendtargets -p 192.168.88.100 -I default --discover</span><br><span class="line">...</span><br><span class="line">192.168.88.100:3260,1 iqn.2471-05.storos.t:27</span><br><span class="line">10.15.117.190:3260,1 iqn.2471-05.storos.t:27</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="挂载设备"><a href="#挂载设备" class="headerlink" title="挂载设备"></a>挂载设备</h3><p>通过<code>fdisk -l</code> 看下挂载前情况</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master1 ~]<span class="comment"># fdisk -l</span></span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 480.1 GB, 480103981056 bytes, 937703088 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 4096 bytes</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>看到只有一块硬盘  <code>/dev/sda</code></p>
<p>然后执行挂载指令，并查看挂载后情况</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master1 ~]<span class="comment"># iscsiadm -m node -T iqn.2471-05.storos.t:27 -p 192.168.88.100 -l</span></span><br><span class="line">[root@master1 ~]<span class="comment"># fdisk -l</span></span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 480.1 GB, 480103981056 bytes, 937703088 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 10.7 GB, 10737418240 bytes, 2621440 sectors</span><br><span class="line">Units = sectors of 1 * 4096 = 4096 bytes</span><br><span class="line">Sector size (logical/physical): 4096 bytes / 4096 bytes</span><br><span class="line">I/O size (minimum/optimal): 4096 bytes / 524288 bytes</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>/dev/sdb</code> 已经被挂载到本地<br>随后使用就和其他磁盘一样，可以格式化、挂载</p>
<h4 id="创建分区"><a href="#创建分区" class="headerlink" title="创建分区"></a>创建分区</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master1 ~]<span class="comment"># fdisk /dev/sdb</span></span><br><span class="line">Welcome to fdisk (util-linux 2.23.2).</span><br><span class="line"></span><br><span class="line">Changes will remain <span class="keyword">in</span> memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write <span class="built_in">command</span>.</span><br><span class="line"></span><br><span class="line">Device does not contain a recognized partition table</span><br><span class="line">Building a new DOS disklabel with disk identifier 0xc26993b8.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): p</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 10.7 GB, 10737418240 bytes, 2621440 sectors</span><br><span class="line">Units = sectors of 1 * 4096 = 4096 bytes</span><br><span class="line">Sector size (logical/physical): 4096 bytes / 4096 bytes</span><br><span class="line">I/O size (minimum/optimal): 4096 bytes / 524288 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0xc26993b8</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition <span class="built_in">type</span>:</span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): p</span><br><span class="line">Partition number (1-4, default 1): </span><br><span class="line">First sector (256-2621439, default 256): </span><br><span class="line">Using default value 256</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (256-2621439, default 2621439): </span><br><span class="line">Using default value 2621439</span><br><span class="line">Partition 1 of <span class="built_in">type</span> Linux and of size 10 GiB is <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w</span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">Syncing disks.</span><br></pre></td></tr></table></figure>

<h4 id="格式化分区"><a href="#格式化分区" class="headerlink" title="格式化分区"></a>格式化分区</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkfs.ext4 /dev/sdb1</span><br></pre></td></tr></table></figure>

<h3 id="会话查看与卸载"><a href="#会话查看与卸载" class="headerlink" title="会话查看与卸载"></a>会话查看与卸载</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master1 ~]<span class="comment"># iscsiadm -m session</span></span><br><span class="line">tcp: [1] 192.168.88.100:3260,1 iqn.2471-05.storos.t:27 (non-flash)</span><br><span class="line">[root@master1 ~]<span class="comment"># </span></span><br><span class="line">[root@master1 ~]<span class="comment"># iscsiadm -m node -T iqn.2471-05.storos.t:27 -p 192.168.88.100 -u</span></span><br><span class="line">Logging out of session [sid: 1, target: iqn.2471-05.storos.t:27, portal: 192.168.88.100,3260]</span><br><span class="line">Logout of [sid: 1, target: iqn.2471-05.storos.t:27, portal: 192.168.88.100,3260] successful.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="CHAP-authentication"><a href="#CHAP-authentication" class="headerlink" title="CHAP authentication"></a>CHAP authentication</h3><p>在IP SAN 里面创建用户<code>test_chap</code> ，密码为<code>test_chap</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master1 ~]# iscsiadm -m node -T iqn.2471-05.storos.t:27 -p 192.168.88.100 -o update --name&#x3D;node.session.auth.username --value&#x3D;test_chap</span><br><span class="line">[root@master1 ~]# iscsiadm -m node -T iqn.2471-05.storos.t:27 -p 192.168.88.100 -o update --name&#x3D;node.session.auth.password --value&#x3D;test_chap</span><br><span class="line">[root@master1 ~]# iscsiadm -m node -T iqn.2471-05.storos.t:27 -p 192.168.88.100 -l</span><br><span class="line">Logging in to [iface: default, target: iqn.2471-05.storos.t:27, portal: 192.168.88.100,3260] (multiple)</span><br><span class="line">Login to [iface: default, target: iqn.2471-05.storos.t:27, portal: 192.168.88.100,3260] successful.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里只描述创建会话的认证过程，搜索过程没做认证</p>
</blockquote>
<h2 id="K8S-使用-iSCSI-作为pv后端"><a href="#K8S-使用-iSCSI-作为pv后端" class="headerlink" title="K8S 使用 iSCSI 作为pv后端"></a>K8S 使用 iSCSI 作为pv后端</h2><h3 id="创建pv"><a href="#创建pv" class="headerlink" title="创建pv"></a>创建pv</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-mysql</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">test-mysql</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">20Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">iscsi:</span></span><br><span class="line">    <span class="attr">targetPortal:</span> <span class="number">192.168</span><span class="number">.88</span><span class="number">.100</span><span class="string">:3260</span></span><br><span class="line">    <span class="attr">iqn:</span> <span class="string">iqn.2471-05.storos.t:27</span></span><br><span class="line">    <span class="attr">fsType:</span> <span class="string">ext4</span></span><br><span class="line">    <span class="attr">lun:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>其中<code>lun</code> 为客户端卷号（在san管理/iSCSI管理界面查询，依据设备不同而不同）</p>
<p>磁盘上如果数据格式不对，无法挂载，最好新建磁盘，让 <code>K8S</code> 自行去做初始化</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Apr 11 13:46:58 master1 kubelet[16033]: E0411 13:46:58.912465   16033 nestedpendingoperations.go:264] Operation <span class="keyword">for</span> <span class="string">&quot;\&quot;kubernetes.io/iscsi/192.168.88.100:3260:iqn.2471-05.storos.t:27:0\&quot;&quot;</span> failed. No retries permitted until 2018-04-11 13:47:06.91242994 +0800 CST (durationBeforeRetry 8s). Error: MountVolume.WaitForAttach failed <span class="keyword">for</span> volume <span class="string">&quot;test-mysql&quot;</span> (UniqueName: <span class="string">&quot;kubernetes.io/iscsi/192.168.88.100:3260:iqn.2471-05.storos.t:27:0&quot;</span>) pod <span class="string">&quot;test-mysql-dd6df7d44-d4jkj&quot;</span> (UID: <span class="string">&quot;6b529d7b-3d4b-11e8-8ab1-0cc47ae55938&quot;</span>) : failed to mount the volume as <span class="string">&quot;ext4&quot;</span>, it already contains unknown data, probably partitions. Mount error: mount failed: <span class="built_in">exit</span> status 32</span><br></pre></td></tr></table></figure>


<h3 id="挂载过程"><a href="#挂载过程" class="headerlink" title="挂载过程"></a>挂载过程</h3><h4 id="kubelet-挂载过程"><a href="#kubelet-挂载过程" class="headerlink" title="kubelet 挂载过程"></a>kubelet 挂载过程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master1 ~]# journalctl -u kubelet -f | grep iscsi</span><br><span class="line">Apr 11 14:19:35 master1 kubelet[16033]: I0411 14:19:35.194301   16033 reconciler.go:212] operationExecutor.VerifyControllerAttachedVolume started for volume &quot;test-mysql&quot; (UniqueName: &quot;kubernetes.io&#x2F;iscsi&#x2F;192.168.88.100:3260:iqn.2471-05.storos.t:27:0&quot;) pod &quot;test-mysql-dd6df7d44-lqj4j&quot; (UID: &quot;38528d0a-3d50-11e8-8ab1-0cc47ae55938&quot;)</span><br><span class="line">Apr 11 14:19:35 master1 kubelet[16033]: I0411 14:19:35.198210   16033 operation_generator.go:684] Controller attach succeeded for volume &quot;test-mysql&quot; (UniqueName: &quot;kubernetes.io&#x2F;iscsi&#x2F;192.168.88.100:3260:iqn.2471-05.storos.t:27:0&quot;) pod &quot;test-mysql-dd6df7d44-lqj4j&quot; (UID: &quot;38528d0a-3d50-11e8-8ab1-0cc47ae55938&quot;) device path: &quot;&quot;</span><br><span class="line">Apr 11 14:19:35 master1 kubelet[16033]: I0411 14:19:35.294607   16033 reconciler.go:257] operationExecutor.MountVolume started for volume &quot;test-mysql&quot; (UniqueName: &quot;kubernetes.io&#x2F;iscsi&#x2F;192.168.88.100:3260:iqn.2471-05.storos.t:27:0&quot;) pod &quot;test-mysql-dd6df7d44-lqj4j&quot; (UID: &quot;38528d0a-3d50-11e8-8ab1-0cc47ae55938&quot;)</span><br><span class="line">Apr 11 14:19:35 master1 kubelet[16033]: I0411 14:19:35.294653   16033 operation_generator.go:416] MountVolume.WaitForAttach entering for volume &quot;test-mysql&quot; (UniqueName: &quot;kubernetes.io&#x2F;iscs&#x2F;192.168.88.100:3260:iqn.2471-05.storos.t:27:0&quot;) pod &quot;test-mysql-dd6df7d44-lqj4j&quot; (UID: &quot;38528d0a-3d50-11e8-8ab1-0cc47ae55938&quot;) DevicePath &quot;&quot;</span><br><span class="line">Apr 11 14:19:35 master1 kubelet[16033]: E0411 14:19:35.314813   16033 iscsi_util.go:233] iscsi: failed to rescan session with error: iscsiadm: No session found.</span><br><span class="line">Apr 11 14:19:36 master1 kubelet[16033]: Mounting arguments: --description&#x3D;Kubernetes transient mount for &#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;plugins&#x2F;kubernetes.io&#x2F;iscsi&#x2F;iface-default&#x2F;192.168.88.100:3260-iqn.2471-05.storos.t:27-lun-0 --scope -- mount -t ext4 -o defaults &#x2F;dev&#x2F;disk&#x2F;by-path&#x2F;ip-192.168.88.100:3260-iscsi-iqn.2471-05.storos.t:27-lun-0 &#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;plugins&#x2F;kubernetes.io&#x2F;iscsi&#x2F;iface-default&#x2F;192.168.88.100:3260-iqn.2471-05.storos.t:27-lun-0</span><br><span class="line">Apr 11 14:19:36 master1 kubelet[16033]: I0411 14:19:36.546450   16033 mount_linux.go:404] Disk &quot;&#x2F;dev&#x2F;disk&#x2F;by-path&#x2F;ip-192.168.88.100:3260-iscsi-iqn.2471-05.storos.t:27-lun-0&quot; appears to be unformatted, attempting to format as type: &quot;ext4&quot; with options: [-F &#x2F;dev&#x2F;disk&#x2F;by-path&#x2F;ip-192.168.88.100:3260-iscsi-iqn.2471-05.storos.t:27-lun-0]</span><br><span class="line">Apr 11 14:19:38 master1 kubelet[16033]: I0411 14:19:38.003506   16033 mount_linux.go:408] Disk successfully formatted (mkfs): ext4 - &#x2F;dev&#x2F;disk&#x2F;by-path&#x2F;ip-192.168.88.100:3260-iscsi-iqn.2471-05.storos.t:27-lun-0 &#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;plugins&#x2F;kubernetes.io&#x2F;iscsi&#x2F;iface-default&#x2F;192.168.88.100:3260-iqn.2471-05.storos.t:27-lun-0</span><br><span class="line">Apr 11 14:19:38 master1 kubelet[16033]: I0411 14:19:38.022322   16033 operation_generator.go:425] MountVolume.WaitForAttach succeeded for volume &quot;test-mysql&quot; (UniqueName: &quot;kubernetes.io&#x2F;iscsi&#x2F;192.168.88.100:3260:iqn.2471-05.storos.t:27:0&quot;) pod &quot;test-mysql-dd6df7d44-lqj4j&quot; (UID: &quot;38528d0a-3d50-11e8-8ab1-0cc47ae55938&quot;)</span><br><span class="line">Apr 11 14:19:38 master1 kubelet[16033]: I0411 14:19:38.022420   16033 operation_generator.go:446] MountVolume.MountDevice succeeded for volume &quot;test-mysql&quot; (UniqueName: &quot;kubernetes.io&#x2F;iscsi&#x2F;192.168.88.100:3260:iqn.2471-05.storos.t:27:0&quot;) pod &quot;test-mysql-dd6df7d44-lqj4j&quot; (UID: &quot;38528d0a-3d50-11e8-8ab1-0cc47ae55938&quot;) device mount path &quot;&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;plugins&#x2F;kubernetes.io&#x2F;iscs&#x2F;iface-default&#x2F;192.168.88.100:3260-iqn.2471-05.storos.t:27-lun-0&quot;</span><br><span class="line">Apr 11 14:19:38 master1 kubelet[16033]: I0411 14:19:38.061696   16033 operation_generator.go:484] MountVolume.SetUp succeeded for volume &quot;test-mysql&quot; (UniqueName: &quot;kubernetes.io&#x2F;iscsi&#x2F;192.168.88.100:3260:iqn.2471-05.storos.t:27:0&quot;) pod &quot;test-mysql-dd6df7d44-lqj4j&quot; (UID: &quot;38528d0a-3d50-11e8-8ab1-0cc47ae55938&quot;)</span><br><span class="line">Apr 11 14:20:21 master1 kubelet[16033]: I0411 14:20:21.347063   16033 reconciler.go:407] Reconciler sync states: could not find pod information in desired or actual states or pending operation, update it in both states: &amp;&#123;volumeName:kubernetes.io&#x2F;iscsi&#x2F;test-mysql:test-mysql:0 podName:38528d0a-3d50-11e8-8ab1-0cc47ae55938 volumeSpec:0xc422c2f760 outerVolumeSpecName:test-mysql pod:0xc42389c380 pluginIsAttachable:true volumeGidValue: devicePath: reportedInUse:false mounter:0xc420bdfc80&#125;</span><br><span class="line">Apr 11 14:20:21 master1 kubelet[16033]: I0411 14:20:21.351063   16033 reconciler.go:547] Volume: kubernetes.io&#x2F;iscsi&#x2F;test-mysql:test-mysql:0 is mounted</span><br></pre></td></tr></table></figure>

<h4 id="主机挂载点查看"><a href="#主机挂载点查看" class="headerlink" title="主机挂载点查看"></a>主机挂载点查看</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master1 ~]# df -h | grep sdb</span><br><span class="line">&#x2F;dev&#x2F;sdb        9.8G  246M  9.0G   3% &#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;pods&#x2F;38528d0a-3d50-11e8-8ab1-0cc47ae55938&#x2F;volumes&#x2F;kubernetes.io~iscsi&#x2F;test-mysql</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master1 ~]# mount |grep kub</span><br><span class="line">&#x2F;dev&#x2F;sdb on &#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;plugins&#x2F;kubernetes.io&#x2F;iscsi&#x2F;iface-default&#x2F;192.168.88.100:3260-iqn.2471-05.storos.t:27-lun-0 type ext4 (rw,relatime,stripe&#x3D;128,data&#x3D;ordered)</span><br><span class="line">&#x2F;dev&#x2F;sdb on &#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;pods&#x2F;38528d0a-3d50-11e8-8ab1-0cc47ae55938&#x2F;volumes&#x2F;kubernetes.io~iscsi&#x2F;test-mysql type ext4 (rw,relatime,stripe&#x3D;128,data&#x3D;ordered)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>


<h3 id="CHAP-authentication-1"><a href="#CHAP-authentication-1" class="headerlink" title="CHAP authentication"></a>CHAP authentication</h3><p>修改PV 的配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">chap-secret</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;kubernetes.io/iscsi-chap&quot;</span>  </span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">node.session.auth.username:</span> <span class="string">aGlrY2xvdWRfY2hhcA==</span></span><br><span class="line">  <span class="attr">node.session.auth.password:</span> <span class="string">aGlrY2xvdWRfY2hhcA==</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-mysql</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">test-mysql</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">20Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">iscsi:</span></span><br><span class="line">    <span class="attr">targetPortal:</span> <span class="number">192.168</span><span class="number">.88</span><span class="number">.100</span><span class="string">:3260</span></span><br><span class="line">    <span class="attr">iqn:</span> <span class="string">iqn.2471-05.storos.t:27</span></span><br><span class="line">    <span class="attr">fsType:</span> <span class="string">ext4</span></span><br><span class="line">    <span class="attr">lun:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">chapAuthDiscovery:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">chapAuthSession:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">secretRef:</span> </span><br><span class="line">       <span class="attr">name:</span> <span class="string">chap-secret</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>secret中其他配置项参见 <a href="https://github.com/open-iscsi/open-iscsi/blob/master/etc/iscsid.conf">Open-iSCSI</a></p>
</blockquote>
<h2 id="CentOS-7-使用-NFS-连接设备"><a href="#CentOS-7-使用-NFS-连接设备" class="headerlink" title="CentOS 7 使用 NFS 连接设备"></a>CentOS 7 使用 NFS 连接设备</h2><p>首先安装nfs工具</p>
<p><code>yum -y install nfs-utils</code></p>
<h3 id="查看NAS的挂载点"><a href="#查看NAS的挂载点" class="headerlink" title="查看NAS的挂载点"></a>查看NAS的挂载点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master1 ~]# showmount -e 192.168.88.100</span><br><span class="line">Export list for 192.168.88.100:</span><br><span class="line">&#x2F;nas&#x2F;test_nfs&#x2F;test_nfs 0.0.0.0&#x2F;0.0.0.0</span><br><span class="line">&#x2F;nas&#x2F;nfs_falcon_db&#x2F;nfs1        0.0.0.0&#x2F;0.0.0.0</span><br><span class="line">&#x2F;nas&#x2F;nfs_falcon_db&#x2F;db          0.0.0.0&#x2F;0.0.0.0</span><br><span class="line">&#x2F;nas&#x2F;nfs_falcon_rtsp&#x2F;rtsp      0.0.0.0&#x2F;0.0.0.0</span><br><span class="line">&#x2F;mnt&#x2F;backup&#x2F;indexbackup        0.0.0.0&#x2F;0.0.0.0</span><br></pre></td></tr></table></figure>

<h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir -p /root/test_nfs</span><br><span class="line">mount -t nfs 192.168.88.100:/nas/test_nfs/test_nfs /root/test_nfs</span><br></pre></td></tr></table></figure>

<h2 id="K8S-使用-NFS-作为pv后端"><a href="#K8S-使用-NFS-作为pv后端" class="headerlink" title="K8S 使用 NFS 作为pv后端"></a>K8S 使用 NFS 作为pv后端</h2><h3 id="创建pv-1"><a href="#创建pv-1" class="headerlink" title="创建pv"></a>创建pv</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-mysql</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">test-mysql</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">10Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.88</span><span class="number">.100</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;/nas/test_nfs/test_nfs&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里遇到一个问题，MySQL 无法启动：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master1 ~]<span class="comment"># kubectl logs -f  mysql-test</span></span><br><span class="line">Initializing database</span><br><span class="line">2018-04-13T03:46:31.653727Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation <span class="keyword">for</span> more details).</span><br><span class="line">2018-04-13T03:46:31.695064Z 0 [ERROR] InnoDB: Unable to lock ./ibdata1 error: 37</span><br><span class="line">2018-04-13T03:46:31.695129Z 0 [ERROR] InnoDB: Operating system error number 37 <span class="keyword">in</span> a file operation.</span><br><span class="line">2018-04-13T03:46:31.695179Z 0 [ERROR] InnoDB: Error number 37 means <span class="string">&#x27;No locks available&#x27;</span></span><br><span class="line">2018-04-13T03:46:31.695194Z 0 [ERROR] InnoDB: Cannot open datafile <span class="string">&#x27;./ibdata1&#x27;</span></span><br><span class="line">2018-04-13T03:46:31.695216Z 0 [ERROR] InnoDB: Could not open or create the system tablespace. If you tried to add new data files to the system tablespace, and it failed here, you should now edit innodb_data_file_path <span class="keyword">in</span> my.cnf back to what it was, and remove the new ibdata files InnoDB created <span class="keyword">in</span> this failed attempt. InnoDB only wrote those files full of zeros, but did not yet use them <span class="keyword">in</span> any way. But be careful: <span class="keyword">do</span> not remove old data files <span class="built_in">which</span> contain your precious data!</span><br><span class="line">2018-04-13T03:46:31.695228Z 0 [ERROR] InnoDB: InnoDB Database creation was aborted with error Cannot open a file. You may need to delete the ibdata1 file before trying to start up again.</span><br><span class="line">2018-04-13T03:46:32.295901Z 0 [ERROR] Plugin <span class="string">&#x27;InnoDB&#x27;</span> init <span class="keyword">function</span> returned error.</span><br><span class="line">2018-04-13T03:46:32.295925Z 0 [ERROR] Plugin <span class="string">&#x27;InnoDB&#x27;</span> registration as a STORAGE ENGINE failed.</span><br><span class="line">2018-04-13T03:46:32.295936Z 0 [ERROR] Failed to initialize <span class="built_in">builtin</span> plugins.</span><br><span class="line">2018-04-13T03:46:32.295941Z 0 [ERROR] Aborting</span><br></pre></td></tr></table></figure>

<p>分析了下就是<code>.lock</code> 文件不能创建，然后就退出了<br>对应的BUG记录<a href="https://bugs.mysql.com/bug.php?id=71969">mysql bug</a><br>意思就是这个是和使用的NFSv3 协议有关系，据说 NFSv4 已经解决，不幸的是我们设备是NFSv3协议的，随后改了下<code>mountOptions</code>，就可以正常使用了:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-mysql</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">test-mysql</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">10Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">   <span class="attr">mountOptions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">nolock</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hard</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">rw</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">proto=tcp</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">vers=3</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">mountvers=3</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">nfsvers=3</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">rsize=524288</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">wsize=524288</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">namlen=255</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.88</span><span class="number">.100</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;/nas/test_nfs/test_nfs&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>kubernetes</tag>
        <tag>nfs</tag>
        <tag>iscsi</tag>
      </tags>
  </entry>
  <entry>
    <title>use of closed network connection</title>
    <url>/posts/e32fa4d.html</url>
    <content><![CDATA[<h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>可靠性验证时，发现大约存在 1/2000 概率存在 节点 NotReady ，并且<strong>不可自愈问题</strong><br>kubelet 报 <code>use of closed network connection</code></p>
<p>现象</p>
<ul>
<li>节点NotReady</li>
<li>kubelet 日志始终打印 <code>use of closed network connection</code></li>
</ul>
<p>初步定位像连接复用没有释放<br>一顿搜索，关联到社区 issue <a href="https://github.com/kubernetes/kubernetes/issues/87615">https://github.com/kubernetes/kubernetes/issues/87615</a><br>看起来就是 golang 的对 h2 处理的 bug</p>
<h2 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h2><p>修复也简单，手动重启 kubelet 即可恢复<br>主要担心其他服务用 client-go 的，可能也有问题，连不上不自愈，但是静默了</p>
<h3 id="方案-1-：-各服务添加环境变量-DISABLE-HTTP2-true，-关闭-http2"><a href="#方案-1-：-各服务添加环境变量-DISABLE-HTTP2-true，-关闭-http2" class="headerlink" title="方案 1 ： 各服务添加环境变量 DISABLE_HTTP2=true， 关闭 http2"></a>方案 1 ： 各服务添加环境变量 <code>DISABLE_HTTP2=true</code>， 关闭 http2</h3><ul>
<li>影响是，http1.1 模式下建链更多，会影响管理面负载</li>
<li>多个服务涉及修改</li>
</ul>
<h3 id="方案-2-：-http2-中进行规避"><a href="#方案-2-：-http2-中进行规避" class="headerlink" title="方案 2 ： http2 中进行规避"></a>方案 2 ： http2 中进行规避</h3><p>一番定位后，找到在 <code>golang.org/x/net/http2/transport.go</code> 里，下面位置是错误返回的地方</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">upgradeFn := <span class="function"><span class="keyword">func</span><span class="params">(authority <span class="keyword">string</span>, c *tls.Conn)</span> <span class="title">http</span>.<span class="title">RoundTripper</span></span> &#123;</span><br><span class="line">	addr := authorityAddr(<span class="string">&quot;https&quot;</span>, authority)</span><br><span class="line">	<span class="keyword">if</span> used, err := connPool.addConnIfNeeded(addr, t2, c); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">go</span> c.Close()</span><br><span class="line">		<span class="keyword">return</span> erringRoundTripper&#123;err&#125;    &lt;--- <span class="string">&quot;use of closed network connection&quot;</span>  rised</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>通过调试，发现此处一旦发生该错误，就无法正常工作了，由此也就有了下面修改代码<br>一旦一个 RoundTripper 反复失败，就退出进程</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> exitedRoundTripper <span class="keyword">struct</span>&#123;</span><br><span class="line">	err   error</span><br><span class="line">	count <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *exitedRoundTripper)</span> <span class="title">RoundTrip</span><span class="params">(*http.Request)</span> <span class="params">(*http.Response, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> e.count &gt;<span class="number">10</span> &#123;</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	e.count ++</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, e.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">upgradeFn := <span class="function"><span class="keyword">func</span><span class="params">(authority <span class="keyword">string</span>, c *tls.Conn)</span> <span class="title">http</span>.<span class="title">RoundTripper</span></span> &#123;</span><br><span class="line">  addr := authorityAddr(<span class="string">&quot;https&quot;</span>, authority)</span><br><span class="line">  <span class="keyword">if</span> used, err := connPool.addConnIfNeeded(addr, t2, c); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">go</span> c.Close()</span><br><span class="line">    <span class="keyword">return</span> &amp;exitedRoundTripper&#123;err: err,countter: <span class="number">0</span>&#125;  &lt;-- </span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>kubernetes</tag>
        <tag>golang</tag>
      </tags>
  </entry>
</search>
